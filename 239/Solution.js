/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function (nums, k) {
  /**
   * 首先说一下思路
   * 这道题是明摆着告诉你是滑动窗口
   * 关键是你该如何实现这个滑动窗口?
   * 如果直接和以前用left和right限制一个范围恐怕是不可行的
   * 这道题要用一个数据结构: 即双端队列
   * 在JS中没有这种数据结构,但是用数组来实现是足够的
   * 在Java中,可以用ArrayDeque
   *
   * 双端队列中存什么呢?
   *  存最大值,并且在维护过程中使得队列中从头到尾是递减的顺序
   * 看例子: 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
   *        输出: [3,3,5,5,6,7]
   * right = 0:  将nums[0]入队  =>  队列[1], res=[]
   * right = 1:  3 大于 队尾元素1  => 1出队, 3入队 => 队列[3], res = [](原因: 要使得队列中递减排序,让3处于一个合适的位置)
   * right = 2:  -1 小于队尾元素 3 => -1入队 => [3, -1],
   *      此时满足 right + 1 >= k, 即窗口长度已经达到k了, 将队首push到结果数组res中 => res=[3]
   * right = 3:  -3 小于队尾元素 -1 => -3入队 => [3, -1, -3]
   *      判断一下队首那个最大值是否还在窗口中: 窗口的大小是k  当前right已知, 那么可以得到right - left + 1 = k
   *      因此left的索引就是right - k + 1
   *      只需判断一下队首元素3的索引是否小于left即可:  此时right为3,则left为1
   *      队首3的索引是1,正好处于left,满足
   *      接着将队首push到res,即res = [3, 3]
   * right = 4: 5 大于队尾元素 -3, 从队尾依次删除元素, 直到队尾元素大于5 或队列为空
   *            此时队列为空, 5入队,队列:[5]
   *            left = 2  队首索引为4, 满足条件
   *            res = [3,3,5]
   * rigth = 5: 3 小于队尾元素 5, 入队 => [5, 3]
   *            left = 3  5索引为4,满足条件
   *            res = [3,3,5,5]
   * right = 6: 6 大于队尾元素, 进行处理, => [6] 索引为6
   *            left = 4 , 满足条件
   *            res = [3,3,5,5,6]
   * right = 7: 7大于队尾元素, 进行处理 ,=> [7]
   *            res = [7]
   *
   * 上述的例子,你会发现队列中如果存值, 你不好去找该值对应的索引
   * 因此, 在实际的代码中, 队列中存索引, 有索引就很容易找到值了
   * 有了上述例子,结合下面的代码,那就很清晰明了了
   *
   * 时间复杂度: O(n)
   * 空间复杂度: O(n)
   *
   *
   */
  if (!nums || k <= 0) return [];
  if (k === 1) return nums;

  // 双向队列deq
  let deq = [];
  // 结果数组res
  let res = [];

  for (let i = 0; i < nums.length; i++) {
    //   如果当前值比队尾大的话, 把队尾删掉, 直到当前元素小于队尾或者队列为空
    while (deq.length > 0 && nums[deq[deq.length - 1]] < nums[i]) {
      deq.pop();
    }

    // 把索引入队
    deq.push(i);

    // 如果队首的最大值在left左边了的话   那就不需要了 删掉
    if (deq[0] < i - k + 1) {
      deq.shift();
    }

    // 最开始窗口长度还不到k的时候, 是不需要向res里push的
    // 直到right + 1大于等于k时  说明窗口已经是达到k了
    // 此后,每次都会向res里加入值
    if (i + 1 >= k) {
      res.push(nums[deq[0]]);
    }
  }

  return res;
};
